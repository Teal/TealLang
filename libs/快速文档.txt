# 一、常量

## 1. 数字
`0, +1, -2, 0.0, 1.0, +0.2, -.3`
> 在语法中并不支持其它格式的数字，其它数字使用如下方式创建： 
>> 大数字: Number("1,223,100")    //在数字中允许逗号或空格    
>> 非数字：Number.NaN   
>> 无穷大: Number.Infinity   
>> 十六进制：Number("0xFFFFF")   
>> 八进制：Number("0777")   
>> 二进制：Number("0b01010000 00000001")   
>> 科学计数法：Number("2e+4")

## 2. 字符串
'', "", ``
> 所有字符串内都允许换行。区别：
> ''是没有转义的原始字符串，在字符串内部用''代替'。
> "" 和 ``完全等效，内部支持使用\开头的转义字符（在不引起歧义时可不加\）。并支持使用$开头的变量。如：  
> a = "1";    
> b = "我的值是 $a"; // b的内容是：我的值是 1     
> c = "我的值是 \$${a+2}"; // c的内容是：我的值是 $3

## 3. 固定值
`true`,    `false` 
`null`:   表示空值。它表示有值，但是值是空的。   
`this`: 代表当前类。不可省略。   
`base`: 代表父类。不可省略。     
`that`: 代表当前函数的调用方的类。比如 obj1.fn() 直接调用了 obj2.gn() 那么，在 obj2.gn() 中 that 代表 obj1。不可省略。   
`out`: 在函数内嵌函数时，对内部函数来说， out 表示外层函数的作用域。在不引起歧义的情况下可以省略。比如 
    fn = { 
        gn = {
            out.b = 2 // 代表在外部作用域创建变量 b,而不是当前作用域。
        };
    }

## 4. 对象    
`[1, 2, 3]` : 列表(List)。  
`(1, 5)`: 数组(Array) 。  
`(key: 1, key2: 4)`: 字典(Dict)。() 代表空的字典。   
`{}`: 函数。具体在下面介绍。
> 对象解析时，多余的","会被忽略。如 [,,,,1,,,,,] 等效于 [1]  


#二、操作符

## 1. 算数操作符
`+, -, *, /, %(取余), ++, --`  

## 2. 赋值操作符
`=, +=, -=,  *=, /=, %=`
`=>(a => c 即 c = a)`

## 3. 比较操作符
`==, !=, <=, >=, <, > `

## 4. 逻辑操作符
`||`: 逻辑或计算，返回布尔值。        
`&&  `    
`!`: 逻辑非         

## 5. 逻辑控制操作符
`a ? b : c` 
`?a`: 判断变量a是否定义，返回布尔值。      
`a | b`: 如果 a 没有定义，则返回 b 。       
`a & b`: 如果 a 已定义，则计算后续表达式。       
`fn() or null`:  执行fn(), 出现错误返回 `null`, 相当于： `try{return fn()}catch{return  null}`     

## 6. 成员操作符
`a.b`     
`a.(true ? "a" : "b")`    
`a[b]`       a..b(链式点操作，如 a..b()..c()..d() 相当于  a.b();a.c();a.d();)         ,
|()    &    !   ||()   &&   &=   |=   &&=  ||=        
a is String(判断 a 是否是 String)       a as String(将 a 转为 String)     Object()(创建类的示例)
fn() or null(
fn()(函数调用)      fn(a:1)(函数调用，传递命名参数)    %fn()(调用函数，但确保函数只执行一次)       a:1(设置默认值，如果a没有定义过，则a的值是1)      


三、基础操作
1. 调试输出
>> 1; // 相当于 Debugger.trace(1);   在系统调试流输出变量。

2. 语句结尾
所有语句都必须用分号结尾，但是编译器会在没有歧义的情况下帮追加分号。

3. 变量无需定义即可直接使用。参数无需声明，也可以通过 @ 直接使用。

a = 1;
fn = {
   >>@p; // 定义参数 p
};
fn(p: 1);  // 匹配参数 p
fn(1);  // 如果没使用命名参数，则参数会根据出现的顺序一一匹配，这里 1 匹配首先出现的参数 p 。

a = 2;
fn = {
   out.a = 4;  // 在函数内部，通过 out 访问外部变量， 如果没有歧义， out. 可以省略。
};

4. 流程语句

if(a) {}
switch(a){case 1: defalt:  }  // 注意，case后会自动插入break，用户无需写也不能写。如果需要case调整，使用 goto case 1   语句。
for(i=0;i<1;i++){}
for(i<1){}     // 只有一个语句时，则代表中间的扩展语句。
注意： 不存在其它关键字和语法提供流程控制。
obj => {
    // 针对 obj 执行函数。并尝试在退出时调用 obj.dispose();
};


5.  调整语句
break
continue
return // 函数的最后一句会自动插入 return 
goto



6.  语句标记：
 init:  a = 1; 
 init: {a = 1};
 
 
 
7. 错误控制
assert a > 5, "hhhh"
throw "OutOfMemory", "aaaaaa"
try{}catch{}
try{}finnaly{}
try{}catch(e){}




8. 类
class Duck : Animal {
   get pro{}
   
   fun {}
   fun(String value){}  //  函数重载
   
   +{} // 操作符的重载

}



9. 函数属性
[a:1]
class Obj {}   //  在类或成员前书写一个 JSON 对象，可以作为类的属性。这个属性不影响代码本身，作为标记使用。



10. 输出参数
fn(p:1, error=>error);  调用fn()   并输出参数 error       。



11. 命名规则

_ 开头表示是私有字段。


四、模块系统

require system;
require ./my;
require http://.com/my
ns = require ./my/code