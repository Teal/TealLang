class Object {

	get type {
		return Native.typeOf(this);
	}

	get hash {
		return Native.getHash(this);
	}
	
	clone() {
		return Native.clone(this);
	}
	
	as String {
		return this.type as String;
	}
	
	== {
		return Native.referenceEquals(this, @value);
	}
	
	!= {
		return !(this == @value);
	}
	
	>> {
		>> this as String
	}
	
}

class Member {
	
	get name {
		return Native.getMemberName(this);
	}
	
	get fullName {
		return Native.getMemberFullName(this);
	}
	
	get attributes {
		return Native.getAttributes(this);
	}

	as String {
		return this.fullName;
	}
	
}

class Type : Member {
	
	
	

}

class Class : Type {

}

class Scope {

}

interface IEnumerable {

	for
	
	as ICollection {
		return this.("get length")? this as Array : this as List;
	}
	
	as Array {
		if(this.("get length")) {
			ret = Array(length: this.length, itemType: this.itemType);
			for(value, key in this) {
				ret[key] = value;
			}
			return ret;
		}
		return this as List as Array;
	}
	
	as List {
		ret = List(this.length, itemType: this.itemType);
		for(value in this) {
			ret.add(value);
		}
		return ret;
	}
	
	# Count the number of all items.
	get count {
		num = 0;
		for(value in this) num++;
		return num;
	}
	
	# Query the current object and return an IEnumerable object.
	# @where The filter function. Items will be enumerated only if `@where(value: "the current value", key: "the current key", target: this) == true`.
	# @desc If set to true. The enumeration will be reversed.
	# @order The comparision function.Items will be swap if `@order(left, right) == true`.
	# return: A List object that contains all items to enumerating.
	query(desc:Bool = false, where:Function?, order?, distinct?, select) {
		for(value, key in this.query(where: where, desc: desc, order: order, distinct: distinct) {
			if(select is Function){
				yield select(value: value, key: key, target: this), key;
			} else {
				yield value.(select), key;
			}
		}
	}
	
	query(desc:Bool = false, where:Function?, order?, distinct?) {
		
		tmp = this.query(where: where) as List;
		
		order & tmp.sort(by: order);
		distinct & tmp.distinct(by: distinct);
		
		return tmp.query(desc: desc);
	}
	
	query(@where:Function){
		for(value, key in this){
			if(@where(value: value, key: key, target: this)){
				yield value, key;
			}
		}
	}
	
	query(@desc:Bool = false) {
		if(@desc){
			if(this.("get length") && this.("get []")) {
				for(i = this.length; --i >= 0; ) {
					yield this[i], i;
				}
			} else {
				// Copy all items to a template array first.
				return (this as Array).query(desc: true);
			}
		} else {
			return this;
		}
	}
	 
	query(@desc:Bool = false, @order?) {
		return (this as Array).sort(order: @order).query(desc: @desc);
	}
	
	#@target Used in `@do(target: @target)`. 
	#@index Used in `@do(index: @index++)`. Set @index = 0 if @do want to known the current iterate count. 
	each(@do:Function, @desc:Bool = false, @where:Function?, @order?, @distinct?, @select, @target = this, @index:Int?){
		for(value, key in this.query(desc: @desc, where: @where, order: @order, distinct: @distinct, select: @select)) {
			if((ret = @do(value: value, key: key, target: @target, index: @index & @index++)) != undefined) 
				return ret;
		}
	}
	
	find(@where?:Function, @result = List(this.length, itemType: this.itemType), @desc:Bool = false, @where:Function?, @order?, @distinct?, @select) {
		index = 0;
		for(value in this.query(desc: @desc, where: @where, order: @order, distinct: @distinct, select: @select)) {
			@result[index++] = value;
		}
		return @result;
	}
	
	find(@which:Function, @desc:Bool = false, @where:Function?, @order?, @distinct?, @select) {
		for(value in this.query(desc: @desc, where: @which, order: @order, distinct: @distinct, select: @select)) {
			return value;
		}
	}
	
	indexOf(@value, @start?, @end?, @length?){
		return this.indexOf(which: {value == @value}, start: @start?, end: @end?, length: @length?);
	}
	
	indexOf(@which, @start:Int = (@end - @length) | 0, @end:Int = (@start + @length) | this.length, @length:Int?) {
		if(!this.("get []")) {
			return (this as ICollection).indexOf(which: @which, start: @start, end: @end, length: @length);
		}
		
		for(; @start < @end; @start++){
			if(@which(value: this[@start], key: @start, target: @target) == true){
				return @start;
			}
		}
		return -1;
	}
	
	indexOf(@where, @start = (@end - @length) | 0, @end = (@start + @length) | this.length, @length?) {
		if(!this.("get []")) {
			return (this as ICollection).indexOf(where: @where, start: @start, end: @end, length: @length);
		}
		
		ret = List();
		for(; @start < @end; @start++){
			if(@where(value: this[@start], key: @start, target: @target) == true){
				ret.add(this[@start]);
			}
		}
		return ret;
	}
	
	contains {
		return this.indexOf(@) >= 0;
	}
	
	copyTo(@to, @toStart = (@toEnd - @length | (@fromEnd - @fromStart)) | 0, @fromStart = (@fromEnd - @length | (@toEnd - @toStart)) | 0, @fromEnd = (@fromStart + @length | (@toEnd - @toStart)) | this.length, @length?){
		if(this == @to && @fromStart < @toStart) {
			toEnd = @toStart + @fromEnd - @fromStart;
			for(@fromStart < @fromEnd){
				to[--toEnd] = this[--@fromEnd];
			}
		} else {
			for(@fromStart < @fromEnd){
				to[@toStart++] = this[@fromStart++];
			}
		}
	}
	
}

interface ICollection : IEnumerable {

	get length;
	
	set length;
	
	get [];
	
	set [];
	
	get [@start, @end = this.length] {
		return Range(data: this, start: @start, end: @end, itemType: this.itemType);
	}
	
	set [@start = 0, @end = this.length] {
		for(;@start < @ned; @start++) { 
			this[@start] = @value;
		}
	}
	
	for {
		for(i = 0; i < this.length; i++) {
			yield this[i], i;
		}
	}
	
	add(@value) {
		this[this.length++] = @value;
	}
	
	add(@value, @at) {
		for(i = this.length++; i > @at; i--){
			this[i] = this[i - 1];
		}
		this[@at] = @value;
	}

	add(@values, @at = this.length) {
		for(value in @values){
			this.add(value: value, at: @at & @at++);
		}
	}
	
	remove(@value) {
		return this.remove(match: {value == @value});
	}
	
	remove(@match:Function) {
		for(value, key in this){
			if(@match(value: value, key: key, target: this) == true) {
				this.remove(at: key);
				return key;
			}
		}
		return -1;
	}
	
	remove(@at:Int) {
		this.copyTo(to: this, fromStart: @at + 1, toStart: @at);
		this[--this.length] = null;
	}
	
	remove(@where:Function) {
		len = 0;
		for(i = 0; i < this.length; i++){
			if(@where(value: this[i], key: i, target: this) != true) {
				this[len++] = this[i];
			}
		}
		if(len < this.length){
			for(;len < this.length; len++){
				this[len] = null;
			}
			return true;
		}
		return false;
	}
	
	remove(@start:Int, @end: Int) {
		assert @start < @end;
		this.copyTo(to: this, fromStart: @end, toStart: @start);
		this[@end, undefined] = null;
	}
	
	remove(@values) {
		for(value in @values){
			this.remove(value: value);
		}
	}
	
	clear {
		this.length = 0;
	}
	
	reverse(@start = 0, @end = this.length - @start) {
		for(; @start < @end; @start++, @end--){
			Object.swap(left => this[@start], right => this[@end]);
		}
	}
	
	sort {
		
	}
	
	distinct {
	
	}
	
}

class List: ICollection {

	get [](@at) {
		return this._data[@at];
	}
	
	get capacity {
		return this._data.length;
	}
	
	set capacity {
		if(@value > this.capacity){
			this._updateCapacity(@value);
		}
	}
	
	_updateCapacity {
		data = Array(@value);
		this._data.copyTo(to: data, fromLength: this.length);
		this._data = data;
	}

	List(@length = 0, @data = Array(length: this.length = @length | 0, itemType: @itemType?), @itemType?) {
		this._data = @data;
	}
	
	add(@value, @at = this.length) {
		if(++this.length == this.capacity){
			this._updateCapacity(this.capacity == 0 ? 4 : this.capacity * 2);
		}
		if(?@at) {
			this._data.copyTo(to: this._data, fromStart: @at, toStart: @at + 1, length: this.length - @at);
		}
		this._data[@at] = @value;
	}
	
	add(@values, @at = this.length) {
	
		// If length is known, use fast copy.
		if(@values.length?) {
			if(@values.length > 0){
			
				if((this.length += @values.length) >= this.capacity){
					// this._updateCapacity(Math.max(this.length, this.capacity * 2));
					this._updateCapacity(this.length);
				}
				
				if(@at?) {
					this._data.copyTo(to: this._data, fromStart: @at, toStart: @at + @values.length, length: this.length - @at);
				}
				
				if(@values.copyTo) {
					@values.copyTo(to: this._data, toStart: @at);
				} else {
					for(value in @values){
						this._data[@at++] = value;
					}
				}
			}
		} else {
			base.add(@);
		}
	}
	
	remove(@at) {
		this._data.copyTo(to: this._data, fromStart: @at, toStart: @at - 1);
		this._data[--this.length] = null;
	}
	
	remove(@start, @length) {
		this._data.copyTo(to: this._data, fromStart: @at, toStart: @at - @length);
		this._data.clear(start: this.length -= @length);
	}
	
	remove(@start, @end) {
		return this.remove(start: @start, length: @end - @start);
	}
	
	remove(@length, @end) {
		return this.remove(start: @end - @length, length: @length);
	}
	
	remove(@where){
		
	}
	
	remove(@value){
		index = this.indexOf(@value);
		if(index >= 0){
			this.remove(at: index);
			return true;
		}
		return false;
	}
	
}


class Module : Scope {


}

class StaticArray {
	
	StaticArray(Object[] data, Int length) {
		this.%data = data;
		this.%length = length;
	}

	[](Int index) {
		return Native.ptrval(this.data, index);
	}
	
	each(Function do) {
		for(i = 0; i < this.length; i++){
			do(key: i, value: this[i]);
		}
	}
	
}

class String {
	
	String(value:Native.type("char*")) {
		this.data = value;
		this.length = Native.strlen(value);
	}
	
	String(value: Native.type("byte*")) {
		this.length = Native.strlen(@value);
		this.data = Native.byteptrtostr(value, this.%length);
	}
	
	String(Native.type("char") value, Int length:0) {
		this.%data = value;
		this.%length = length;
	}
	
	clone() {
		return this;
	}
	
	+(value:String) {
		if(value == null || value.length == 0){
			return this;
		}
		totolLength = this.length + value.length;
		data = Native.allocString(totolLength);
		Native.wstrcpy(Native.wstrcpy(data, this.data, this.length), value.data, value.length);
		return String(data, totolLength);
	}
	
	==(String value) {
		if(this.length != value.length){
			return true;
		}
		
		return Native.streq(this.data, value.data, this.length);
	}
	
	concat(String[] values) {
		totolLength = 0;
		values.each {
			totolLength += @value.length;
		};
		data = Native.allocString(totolLength);
		ret = String(data, totolLength);
		values.each {
			data = Native.wstrcpy(data, @value.data, @value.length);
		}
		return ret;
	}
	
	[](Int index) {
		return index >= 0 && index < this.length ? Native.charat(this.data, index) : '\0';
	}
	
	each = StaticArray.each
	
	equals(@value) {
		if(?@ignoreCase == true){
		}
		
		return this == value;
	}
	
}

struct DateTime {

	DateTime(Int value) {
		this.@data = value;
	}
	
	DateTime(Int year:1970, Int month:0,Int day:0, Int hour:0, Int minute:0, Int second:0) {
		this.@data = year + month + day + hour + minute + second;
	}
	
	add(Int year) {
	
	}
	
	add(Int month) {
	
	}
	
	daysInMonth {
		
	
	}
	
	get day {
	
	}

	+ {
	
	}
}

struct Number {

}

struct Int : Number {

}

struct BigInt : Int {

}

struct Decimal : Number {

}

struct Float : Number {

}

struct Byte {

}

struct Char {

}

struct Bool {

}

struct Null {

}

class Buffer {
	
}

namespace Math {


}

class Encoding {


}

class Regex {

	Regex(String pattern) {
		
	}

}

# 表示一个 FTP 服务器。
#
# 	FtpClient() => {
#		@ftp.open("localhost", 21, "userName", "password");
#		>> @ftp.getFiles()
#	}
class FtpClient {

	FtpClient{
		this.passive = @passive | true;
		this.connTimeout = @connTimeout | -1;
		this.openTimeout = @openTimeout | -1;
	}
	
	open(Url url) {
		return this.open(url.server, url.port, url.userName, url.password);
	}

	open {
		this._socket = Socket(server:@server, port:@port | 21, sendTimeout: this.openTimeout, receiveTimeout: this.connTimeout)..open() ;
		
		@userName & this.login(@userName, @password);
		
	}
	
	close = this._socket.close
	
	sendCommand {
		this._socket.send(@command + "\r\n");
	}
	
	dispose = this.close
	
	list {
	
	}
	
	login {
		
	}

}


namespace Console {

	write {
		@.each { Native.stdput(@value); }
		
		if(?@appendLine == true){
			Native.stdputline();
		}
	}
	
	read {
		if(?@key) {
			return @key = Native.stdkey(@intercept);
		}
	
	}

}

class Obj {

	value;
	
	fn{
		this.$vals = @gg;
	}

}

namespace Environment {
	
	get isWindows {
		return Native.getOS() === 1;
	}
	
	get isUnix {
		return Native.getOS() === 2;
	}
	
	get isMac {
		return Native.getOS() === 3;
	}
	
	newLine = Environment.isWindows ? "\r\n" : Environment.isMac ? "\r" : "\n"; 
	
	get exitCode {
		return Native.getExitCode();
	}
	
	set exitCode {
		return Native.getExitCode(@value);
	}
	
	get uptime {
		return Native.getUptime(@value);
	}
	
}

# 处理所有的路径。
namespace Path {

	dirSeparator = Environment.isWindows ? '/' : '\';
	
	altDirSeparator = Environment.isWindows ? '\' : '/';
	
	pathSeparator = Environment.isWindows ? ';' : '/';
	
	volumeSeparator = Environment.isWindows ? ':' : '/';
	
	maxLength = 260,

	isSeparator {
		return @value == Path.dirSeparator || @value == Path.altDirSeparator || @value == Path.volumeSeparatorChar;
	}

	changeExtension {
		extensionIndex = @path.indexOf(desc: true, value: '.', until: Path.isSeparator);
		@extension = @extension.prepend('.');
		return extensionIndex >= 0 ? @path.replace(start: extensionIndex, to: @extension) : (@path + @extension);
	}
	
	concat {
	
	}
	
	getDirName {
		return @path.substring(desc: true, end: {@value == Path.dirSeparator || @value == Path.altDirSeparator});
	}
	
	getExtension {
		return @path.substring(desc: true, start: '.', until: Path.isSeparator);
	/*
		return @path.each(
			desc: true,
			do: {
				if(@value == '.'){
					return @target.substring(@index);
				}
				
				if(@value == '/' || @value == '\' || @value == ':') {
					return '';
				}
			
			}
		) | '';
	 */
	}
	
	getFileName {
		return @path.substring(desc: true, start: Path.isSeparator);
	}
	
	getFileNameWithoutExtension {
		return @path.substring(desc: true, start: Path.isSeparator, end: '.');
	}
	
	getRandomFileName {
	
	}
	
	getTempFileName {
	
	}
	
	getTempPath {
	
	}
	
	hasExtension(@path, @extension) {
		return @path.endsWith(@extension.prepend('.'));
	}
	
	hasExtension {
		return @path.indexOf(desc: true, value: '.', until: Path.isSeparator) >= 0;
	}
	
	normalize {
	
	}
	
	resovle {
	
	}
	
	relative {
	
	}

}


class Dict {

	Dict {
		Native.initDict(this, @);
	}
	
	. {
		
	}

}


class File {

	

}


o = Obj();
o.fn();
